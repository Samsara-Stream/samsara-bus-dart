import 'dart:async';
import 'package:samsara_bus_dart/samsara_bus_dart.dart';
import 'package:samsara_bus_exchange_dart/samsara_bus_exchange_dart.dart';

/// Example demonstrating the Exchange pattern with annotations.
///
/// Note: In a real implementation, the classes marked with @ExchangeClient
/// and @ExchangeService would have their implementations generated by build_runner.
/// This example shows the manual implementations for demonstration purposes.

void main() async {
  print('Exchange Pattern Example');
  print('========================');

  final bus = DefaultSamsaraBus();

  bus.registerTopic<Map<String, dynamic>>(
      'math.request', TopicType.publishSubject);
  bus.registerTopic<Map<String, dynamic>>(
      'math.response', TopicType.publishSubject);

  final mathService = MathService$Generated(bus);
  final mathClient = MathClient$Generated(bus);

  await mathService.start();

  print('Making requests using Exchange pattern...\n');

  try {
    final addResult = await mathClient.add(5, 3);
    print('5 + 3 = $addResult');

    final subtractResult = await mathClient.subtract(10, 4);
    print('10 - 4 = $subtractResult');

    final multiplyResult = await mathClient.multiply(7, 6);
    print('7 * 6 = $multiplyResult');

    final divideResult = await mathClient.divide(20, 4);
    print('20 / 4 = $divideResult');

    print('\nTrying division by zero...');
    try {
      await mathClient.divide(10, 0);
    } catch (e) {
      print('Error caught: $e');
    }
  } catch (e) {
    print('Error: $e');
  }

  await mathService.stop();
  mathClient.dispose();
  await bus.close();

  print('\nExample completed.');
}

// ============================================================================
// Service Definition (would be generated from annotation)
// ============================================================================

@ExchangeService('math.request', 'math.response')
abstract class MathService {
  @ServiceMethod()
  double add(double a, double b);

  @ServiceMethod()
  double subtract(double a, double b);

  @ServiceMethod()
  double multiply(double a, double b);

  @ServiceMethod()
  double divide(double a, double b);
}

// Generated implementation (normally generated by build_runner)
class MathService$Generated extends ExchangeServiceBase implements MathService {
  MathService$Generated(SamsaraBus bus)
      : super(bus, 'math.request', 'math.response');

  @override
  Future<dynamic> handleOperation(
      String operation, Map<String, dynamic> params) async {
    final a = (params['a'] as num).toDouble();
    final b = (params['b'] as num).toDouble();

    switch (operation) {
      case 'add':
        return add(a, b);
      case 'subtract':
        return subtract(a, b);
      case 'multiply':
        return multiply(a, b);
      case 'divide':
        return divide(a, b);
      default:
        throw Exception('Unknown operation: $operation');
    }
  }

  @override
  double add(double a, double b) => a + b;

  @override
  double subtract(double a, double b) => a - b;

  @override
  double multiply(double a, double b) => a * b;

  @override
  double divide(double a, double b) {
    if (b == 0) throw Exception('Division by zero');
    return a / b;
  }
}

// ============================================================================
// Client Definition (would be generated from annotation)
// ============================================================================

@ExchangeClient('math.request', 'math.response',
    defaultTimeout: Duration(seconds: 5))
abstract class MathClient {
  @ExchangeMethod()
  Future<double> add(double a, double b);

  @ExchangeMethod()
  Future<double> subtract(double a, double b);

  @ExchangeMethod(timeout: Duration(seconds: 10))
  Future<double> multiply(double a, double b);

  @ExchangeMethod()
  Future<double> divide(double a, double b);
}

// Generated implementation (normally generated by build_runner)
class MathClient$Generated extends ExchangeClientBase implements MathClient {
  MathClient$Generated(SamsaraBus bus)
      : super(bus, 'math.request', 'math.response',
            defaultTimeout: Duration(seconds: 5));

  @override
  Future<double> add(double a, double b) async {
    final result = await makeRequest<double>('add', {'a': a, 'b': b});
    return result;
  }

  @override
  Future<double> subtract(double a, double b) async {
    final result = await makeRequest<double>('subtract', {'a': a, 'b': b});
    return result;
  }

  @override
  Future<double> multiply(double a, double b) async {
    final result = await makeRequest<double>('multiply', {'a': a, 'b': b},
        timeout: Duration(seconds: 10));
    return result;
  }

  @override
  Future<double> divide(double a, double b) async {
    final result = await makeRequest<double>('divide', {'a': a, 'b': b});
    return result;
  }
}
